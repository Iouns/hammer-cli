#!/usr/bin/env ruby
# Copyright (C) 2011 Vijay Brian Gupta brian.gupta@brandorr.com
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
# USA.

require "rubygems"
require "rest_client"
require "json"
require "yaml"
require "clamp"

module Hammer

  class ForemanResource
    @@foreman_interface = nil

    def self.connect!(url, opts = {})
      @@foreman_interface = RestClient::Resource.new(url, opts)
    end

    def self.connection
      @@foreman_interface || nil
    end

    def self.get_resource(path)
      JSON.parse(@@foreman_interface[path].get.body)
    end

#    def self.get_collection(path, foreman_config = {}, options = {})
#      RestClient.log = 'stdout' if foreman_config[:debug]
#      JSON.parse(RestClient::Request.new({:method  => :get,
#                                     :url     => "#{foreman_config[:foreman_url]}/#{path.to_s.chomp('/')}",
#                                     :user    => foreman_config[:foreman_user], :password => foreman_config[:foreman_pass],
#                                     :headers => { :accept => :json, :content_type => :json }}.merge(options)).execute.to_s)
#    end

    def self.print_response(response, format)

      puts(case format
        when "json"
          JSON.pretty_generate(response)
        when "yaml"
          YAML.dump(response)
        else
          r = response.first
          if r.is_a?(Hash)
          # we simply return host list
          if r.first[0] == "host"
            response.map{|h| h["host"]["name"]}
          else
            response.map{|o| o.inspect}
          end
          else
            response.join("\n")
          end
        end)
    end

#    def search_collection(path,search)
#      get_collection(path, :url => "#{@foreman_url}/#{path}?search=#{URI.encode(search)}")
#    end

  end

  class HammerCommand < Clamp::Command

    option ["-d", "--debug"], :flag, "Output more information"
    option ["-u", "--user"], "USER", "Foreman user"
    option ["-p", "--pass"], "PASSWORD", "Foreman password"
    option ["-s", "--server"], "URL", "Foreman Server URL", :default => "http://localhost/"
#    option "--format", "FORMAT", "Output format", :default => "json"# do |s|
#      unless ['json', 'yaml', 'text'].include?(s)
#        raise ArgumentError, "must be one of: ['json', 'yaml', 'text']"
#      end
#      s
#    end
    option "--version", :flag, "show version" do
      puts "hammer-1.0.0"
      exit(0)
    end

    def allowed_content_types
      return [ "json", "yaml", "text" ]
    end

    def default_content_type
      return "json"
    end

    def self.establish_connection(url, user, pass)
      headers = { :accept => 'json', :content_type => 'json' }
      ForemanResource.connect!(url, :user => user, :password => pass, :headers => headers) if ForemanResource.connection.nil?
    end

  end

  class DomainListCommand < HammerCommand
    def execute
      puts "Domain list here."
      #raise NotImplementedError
    end
  end

  class DomainShowCommand < HammerCommand
    def execute
      puts "Domain show here."
      #raise NotImplementedError
    end
  end

  class DomainCreateCommand < HammerCommand
    def execute
      puts "Domain create here."
      #raise NotImplementedError
    end
  end

  class DomainDeleteCommand < HammerCommand
    def execute
      puts "Domain delete here."
      #raise NotImplementedError
    end
  end

  class DomainUpdateCommand < HammerCommand
    def execute
      puts "Domain update here."
      #raise NotImplementedError
    end
  end

  class DomainCommand < HammerCommand
    subcommand "list", "List domains.", DomainListCommand
    subcommand "show", "Show domains.", DomainShowCommand
    subcommand "create", "Create domains.", DomainCreateCommand
    subcommand "delete", "Delete domains.", DomainDeleteCommand
    subcommand "update", "Update domains.", DomainUpdateCommand
  end

  class EnvironmentListCommand < HammerCommand
    def execute
      puts "Environment list here."
      #raise NotImplementedError
    end
  end

  class EnvironmentShowCommand < HammerCommand
    def execute
      puts "Environment show here."
      #raise NotImplementedError
    end
  end

  class EnvironmentCreateCommand < HammerCommand
    def execute
      puts "Environment create here."
      #raise NotImplementedError
    end
  end

  class EnvironmentDeleteCommand < HammerCommand
    def execute
      puts "Environment delete here."
      #raise NotImplementedError
    end
  end

  class EnvironmentUpdateCommand < HammerCommand
    def execute
      puts "Environment update here."
      #raise NotImplementedError
    end
  end

  class EnvironmentCommand < HammerCommand
    subcommand "list", "List environments.", EnvironmentListCommand
    subcommand "show", "Show environments.", EnvironmentShowCommand
    subcommand "create", "Create environments.", EnvironmentCreateCommand
    subcommand "delete", "Delete environments.", EnvironmentDeleteCommand
    subcommand "update", "Update environments.", EnvironmentUpdateCommand
  end

  class HostListCommand < HammerCommand

    option "--format", "FORMAT", "Output format"

    def default_content_type
      return "text"
    end

    def default_format
       default_content_type
    end

    def format= s
      raise ArgumentError, "must be one of: #{allowed_content_types.join(', ')}" unless allowed_content_types.include?(s)
      @format = s
    end

    def execute
      HammerCommand.establish_connection(server, user, pass) if ForemanResource.connection.nil?
      ForemanResource::print_response(ForemanResource::get_resource('hosts'), format)
    end

  end

  class HostShowCommand < HammerCommand

    parameter "FQDN", "host to show"

    option "--format", "FORMAT", "Output format"

    def allowed_content_types
      return [ "json", "yaml" ]
    end

    def default_format
       default_content_type
    end

    def format= s
      raise ArgumentError, "must be one of: #{allowed_content_types.join(', ')}" unless allowed_content_types.include?(s)
      @format = s
    end

    def execute
      ForemanResource::print_response(ForemanResource::get_collection('hosts'+"/"+fqdn, {:foreman_url => server, :foreman_user => user, :foreman_pass => pass, :debug => debug?}), format)
    end
  end

  class HostCreateCommand < HammerCommand
    def execute
      puts "Host create here."
      #raise NotImplementedError
    end
  end

  class HostDeleteCommand < HammerCommand
    def execute
      puts "Host delete here."
      #raise NotImplementedError
    end
  end

  class HostUpdateCommand < HammerCommand
    def execute
      puts "Host update here."
      #raise NotImplementedError
    end
  end

  class HostCommand < HammerCommand
    subcommand "list", "List hosts.", HostListCommand
    subcommand "show", "Show hosts.", HostShowCommand
    subcommand "create", "Create hosts.", HostCreateCommand
    subcommand "delete", "Delete hosts.", HostDeleteCommand
    subcommand "update", "Update hosts.", HostUpdateCommand
  end

  class MainCommand < HammerCommand

    subcommand "domain", "Work with domains.", DomainCommand
    subcommand "environment", "Work with environments.", EnvironmentCommand
    subcommand "host", "Work with hosts.", HostCommand
#    subcommand "exec", "Work with hostgroups.", HostgroupCommand
#    subcommand "help", "Work with hostgroups.", HostgroupCommand
#    subcommand "search", "Work with hostgroups.", HostgroupCommand
#    subcommand "status", "Work with hostgroups.", HostgroupCommand
#    subcommand "dns", "Work with hostgroups.", HostgroupCommand
#    subcommand "dhcp", "Work with hostgroups.", HostgroupCommand
#    subcommand "tftp", "Work with hostgroups.", HostgroupCommand
#    subcommand "puppetca", "Work with hostgroups.", HostgroupCommand
#    subcommand "puppet", "Work with hostgroups.", HostgroupCommand
#    subcommand "server", "Work with hostgroups.", HostgroupCommand

  end

end

Hammer::MainCommand.run
